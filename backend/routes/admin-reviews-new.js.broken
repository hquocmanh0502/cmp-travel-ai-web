const express = require('express');
const router = express.Router();
const Comment = require('../models/Comment');

const express = require('express');
const router = express.Router();
const Comment = require('../models/Comment');

// GET /api/admin/reviews - Get all reviews with efficient search + pagination
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, search, rating, verified } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    console.log('\nüîç REVIEWS API REQUEST:', { page, limit, search, rating, verified });
    
    // Build base filter
    let baseFilter = {};
    
    if (rating && rating !== 'all') {
      baseFilter['content.rating'] = parseInt(rating);
    }
    
    if (verified && verified !== 'all') {
      baseFilter['verified.isVerified'] = verified === 'true';
    }

    let paginatedReviews, totalFilteredResults;

    if (search && search.trim()) {
      console.log(`üîé Performing search for: "${search}"`);
      
      // Use aggregation pipeline for cross-collection search
      const searchRegex = new RegExp(search, 'i');
      
      const pipeline = [
        { $match: baseFilter },
        {
          $lookup: {
            from: 'users',
            localField: 'userId',
            foreignField: '_id',
            as: 'user'
          }
        },
        {
          $lookup: {
            from: 'tours', 
            localField: 'tourId',
            foreignField: '_id',
            as: 'tour'
          }
        },
        {
          $match: {
            $or: [
              { 'content.text': searchRegex },
              { 'user.fullName': searchRegex },
              { 'user.email': searchRegex },
              { 'tour.name': searchRegex },
              { 'tour.country': searchRegex }
            ]
          }
        },
        { $sort: { 'timestamps.createdAt': -1 } }
      ];

      // Get total count
      const countPipeline = [...pipeline, { $count: 'total' }];
      const countResult = await Comment.aggregate(countPipeline);
      totalFilteredResults = countResult[0]?.total || 0;

      // Get paginated results
      const dataPipeline = [
        ...pipeline,
        { $skip: skip },
        { $limit: parseInt(limit) }
      ];
      
      const results = await Comment.aggregate(dataPipeline);
      
      // Transform aggregation results to match populate format
      paginatedReviews = results.map(doc => ({
        ...doc,
        userId: doc.user[0] || null,
        tourId: doc.tour[0] || null
      }));
      
      console.log(`üîé Search found ${totalFilteredResults} total results, showing ${results.length}`);
      
    } else {
      console.log('üìã No search - using regular pagination');
      
      // Regular pagination without search
      totalFilteredResults = await Comment.countDocuments(baseFilter);
      
      paginatedReviews = await Comment.find(baseFilter)
        .populate('userId', 'fullName email avatar')
        .populate('tourId', 'name country img')
        .sort({ 'timestamps.createdAt': -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean();
        
      console.log(`üìÑ Found ${totalFilteredResults} total, showing ${paginatedReviews.length}`);
    }

    if (paginatedReviews.length > 0) {
      console.log('üë§ First review user:', paginatedReviews[0].userId?.fullName || 'No user');
      console.log('üèñÔ∏è First review tour:', paginatedReviews[0].tourId?.name || 'No tour');
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, search, rating, verified } = req.query;
    const skip = (parseInt(page) - 1) * parseInt(limit);
    
    console.log('\nüîç REVIEWS API REQUEST:', { page, limit, search, rating, verified });
    
    // Build base filter object for DB query
    let baseFilter = {};
    
    // Rating filter
    if (rating && rating !== 'all') {
      baseFilter['content.rating'] = parseInt(rating);
    }
    
    // Verified filter  
    if (verified && verified !== 'all') {
      baseFilter['verified.isVerified'] = verified === 'true';
    }

    // Build search filter for MongoDB query (more efficient than JS filter)
    let searchFilter = { ...baseFilter };
    if (search && search.trim()) {
      const searchRegex = new RegExp(search, 'i'); // case-insensitive regex
      searchFilter.$or = [
        { 'content.text': searchRegex }
        // Note: User and Tour search will be done after populate since it's across collections
      ];
      console.log('üîé Added search filter to MongoDB query:', search);
    }

    console.log('üìã MongoDB Filter applied:', searchFilter);

    // Build final query with search conditions
    let finalQuery = { ...baseFilter };
    
    if (search && search.trim()) {
      const searchRegex = new RegExp(search, 'i');
      
      // For cross-collection search, we need to use aggregation pipeline
      const pipeline = [
        { $match: baseFilter },
        {
          $lookup: {
            from: 'users',
            localField: 'userId', 
            foreignField: '_id',
            as: 'user'
          }
        },
        {
          $lookup: {
            from: 'tours',
            localField: 'tourId',
            foreignField: '_id', 
            as: 'tour'
          }
        },
        {
          $match: {
            $or: [
              { 'content.text': searchRegex },
              { 'user.fullName': searchRegex },
              { 'user.email': searchRegex },
              { 'tour.name': searchRegex },
              { 'tour.country': searchRegex }
            ]
          }
        },
        { $sort: { 'timestamps.createdAt': -1 } }
      ];

      // Get total count for search results
      const totalCountPipeline = [...pipeline, { $count: "total" }];
      const totalResult = await Comment.aggregate(totalCountPipeline);
      const totalFilteredResults = totalResult[0]?.total || 0;

      console.log(`üîé Search "${search}" found ${totalFilteredResults} results`);

      // Get paginated search results
      const resultsPipeline = [
        ...pipeline,
        { $skip: skip },
        { $limit: parseInt(limit) }
      ];

      const searchResults = await Comment.aggregate(resultsPipeline);
      
      // Transform aggregation results back to populated format
      const paginatedReviews = searchResults.map(result => ({
        ...result,
        userId: result.user[0] || null,
        tourId: result.tour[0] || null
      }));

      console.log(`ÔøΩ Returning ${paginatedReviews.length} search results (page ${page})`);

      return { paginatedReviews, totalFilteredResults };
    } else {
      // No search - use regular pagination
      const totalFilteredResults = await Comment.countDocuments(baseFilter);
      
      const paginatedReviews = await Comment.find(baseFilter)
        .populate('userId', 'fullName email avatar')
        .populate('tourId', 'name country img')
        .sort({ 'timestamps.createdAt': -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean();

      console.log(`ÔøΩ Returning ${paginatedReviews.length} of ${totalFilteredResults} total reviews (page ${page})`);
      
      return { paginatedReviews, totalFilteredResults };
    }

    // Extract results from the return block above
    const { paginatedReviews, totalFilteredResults } = await (async () => {
    
    console.log(`üìÑ Pagination: showing ${paginatedReviews.length} of ${totalFilteredResults} total results (page ${page})`);
    
    if (paginatedReviews.length > 0) {
      console.log('üë§ First review user:', paginatedReviews[0].userId?.fullName);
      console.log('üèñÔ∏è First review tour:', paginatedReviews[0].tourId?.name);
      console.log('üí¨ First review content:', paginatedReviews[0].content?.text?.substring(0, 50) + '...');
    }

    // Transform to frontend format
    const transformedReviews = paginatedReviews.map(review => ({
      id: review._id,
      _id: review._id,
      userName: review.userId?.fullName || 'Unknown User',
      userEmail: review.userId?.email || 'No email',
      userAvatar: review.userId?.avatar || `https://ui-avatars.com/api/?name=${encodeURIComponent(review.userId?.fullName || 'User')}&background=0D8ABC&color=fff`,
      tourName: review.tourId?.name || 'Unknown Tour',
      tourCountry: review.tourId?.country || 'Unknown',
      tourImage: review.tourId?.img?.[0] || '',
      rating: review.content?.rating || 0,
      comment: review.content?.text || '',
      images: review.content?.images || [],
      detailedRating: review.content?.detailedRating || {},
      status: review.moderation?.status || 'pending',
      verified: review.verified?.isVerified || false,
      verifiedAt: review.verified?.verifiedAt,
      date: review.timestamps?.createdAt || new Date(),
      updatedAt: review.timestamps?.updatedAt,
      helpful: review.reactions?.helpful?.length || 0,
      likes: review.reactions?.likes?.length || 0,
      repliesCount: review.replies?.length || 0,
      aiAnalysis: {
        sentiment: review.aiAnalysis?.sentiment?.label || 'neutral',
        toxicity: review.aiAnalysis?.toxicity || 0,
        categories: review.aiAnalysis?.categories || []
      },
      tripDetails: review.tripDetails || {}
    }));

    // Calculate pagination stats based on filtered results
    const totalPages = Math.ceil(totalFilteredResults / parseInt(limit));

    console.log(`‚úÖ Returning ${transformedReviews.length} transformed reviews`);
    console.log(`üìä Pagination: ${totalFilteredResults} total, ${totalPages} pages, current page ${page}`);

    res.json({
      success: true,
      data: transformedReviews,
      stats: {
        total: totalFilteredResults,
        page: parseInt(page),
        totalPages: totalPages,
        hasNext: parseInt(page) * parseInt(limit) < totalFilteredResults,
        hasPrev: parseInt(page) > 1,
        showing: `${skip + 1}-${Math.min(skip + parseInt(limit), totalFilteredResults)} of ${totalFilteredResults}`
      }
    });

  } catch (error) {
    console.error('‚ùå Error fetching reviews:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error',
      error: error.message 
    });
  }
});

// GET /api/admin/reviews/stats - Get review statistics
router.get('/stats', async (req, res) => {
  try {
    console.log('üìä Fetching review statistics...');
    
    const total = await Comment.countDocuments();
    const pending = await Comment.countDocuments({ 'moderation.status': 'pending' });
    const approved = await Comment.countDocuments({ 'moderation.status': 'approved' });
    const rejected = await Comment.countDocuments({ 'moderation.status': 'rejected' });
    const verified = await Comment.countDocuments({ 'verified.isVerified': true });
    
    // Average rating
    const ratingStats = await Comment.aggregate([
      { $match: { 'content.rating': { $exists: true } } },
      { $group: { _id: null, avgRating: { $avg: '$content.rating' } } }
    ]);
    
    const avgRating = ratingStats[0]?.avgRating || 0;

    const stats = {
      total,
      pending,
      approved, 
      rejected,
      verified,
      avgRating: Math.round(avgRating * 10) / 10
    };

    console.log('üìà Review stats:', stats);

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('‚ùå Error fetching stats:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error',
      error: error.message 
    });
  }
});

// PUT /api/admin/reviews/:id/status - Update review status
router.put('/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    console.log(`üìù Updating review ${id} status to: ${status}`);

    const review = await Comment.findByIdAndUpdate(
      id,
      { 
        'moderation.status': status,
        'timestamps.updatedAt': new Date()
      },
      { new: true }
    );

    if (!review) {
      return res.status(404).json({
        success: false,
        message: 'Review not found'
      });
    }

    res.json({
      success: true,
      message: 'Status updated successfully',
      data: review
    });

  } catch (error) {
    console.error('‚ùå Error updating status:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error',
      error: error.message 
    });
  }
});

// POST /api/admin/reviews/:id/reply - Add admin reply to review
router.post('/:id/reply', async (req, res) => {
  try {
    const { id } = req.params;
    const { text, adminName = 'Admin' } = req.body;

    if (!text) {
      return res.status(400).json({
        success: false,
        message: 'Reply text is required'
      });
    }

    console.log(`üí¨ Adding admin reply to review ${id}`);

    const review = await Comment.findById(id);
    if (!review) {
      return res.status(404).json({
        success: false,
        message: 'Review not found'
      });
    }

    // Add reply to the replies array
    const newReply = {
      userId: null, // Admin reply doesn't need userId
      text: text,
      timestamp: new Date(),
      isAdmin: true,
      adminRole: 'customer_service',
      moderation: {
        processed: true,
        status: 'approved',
        isSpam: false,
        confidence: 1,
        requiresReview: false
      }
    };

    review.replies.push(newReply);
    review.timestamps.updatedAt = new Date();

    await review.save();

    console.log(`‚úÖ Admin reply added to review ${id}`);

    res.json({
      success: true,
      message: 'Reply added successfully',
      data: {
        replyId: newReply._id,
        reply: newReply
      }
    });

  } catch (error) {
    console.error('‚ùå Error adding reply:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error',
      error: error.message 
    });
  }
});

// DELETE /api/admin/reviews/:id - Delete review
router.delete('/:id', async (req, res) => {
  try {
    const { id } = req.params;
    
    console.log(`üóëÔ∏è Deleting review ${id}`);

    const review = await Comment.findByIdAndDelete(id);

    if (!review) {
      return res.status(404).json({
        success: false,
        message: 'Review not found'
      });
    }

    res.json({
      success: true,
      message: 'Review deleted successfully'
    });

  } catch (error) {
    console.error('‚ùå Error deleting review:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Internal server error',
      error: error.message 
    });
  }
});

module.exports = router;